module PC(in,clk,out);
  input [31:0]in;
  input clk;
  output reg [31:0]out;
  always@(posedge clk)
    out<=in;
endmodule

module InstrMem(in,out);
  input [31:0] in;
  output [31:0] out;
  // cititre din fisier a instructiunilor
  // out e codificarea instructiunii
  // in e adresa din fisier 
  // fiecare instructiune are 4bytes
  
  
endmodule

module Control(opcode, RegDst, Jump, Branch, MemRead, MemToReg, ALUOp, MemWrite, ALUSrc, RegWrite);
  input [5:0] opcode;
  output reg RegDst, Jump, Branch, MemRead, MemToReg,  MemWrite, ALUSrc, RegWrite;
  output reg [1:0] ALUOp;
  
  // de facut case
  always@(opcode)
    casex(opcode)
        6'b000000: {RegDst, Jump, Branch, MemRead, MemToReg, ALUOp,  MemWrite, ALUSrc, RegWrite} <= 10'b1_0_0_0_0_10_0_0_1; //R-TYPE
        6'b100011: {RegDst, Jump, Branch, MemRead, MemToReg, ALUOp,  MemWrite, ALUSrc, RegWrite} <= 10'b0_0_0_1_1_00_0_1_1; //LW
        6'b101011: {RegDst, Jump, Branch, MemRead, MemToReg, ALUOp,  MemWrite, ALUSrc, RegWrite} <= 10'bX_0_0_0_X_00_1_1_0; //SW
        6'b000100: {RegDst, Jump, Branch, MemRead, MemToReg, ALUOp,  MemWrite, ALUSrc, RegWrite} <= 10'bX_0_1_0_X_01_0_0_0; //BEQ
        6'b001000: {RegDst, Jump, Branch, MemRead, MemToReg, ALUOp,  MemWrite, ALUSrc, RegWrite} <= 10'b1_0_0_0_0_00_0_1_1; //ADDI
        6'b001000: {RegDst, Jump, Branch, MemRead, MemToReg, ALUOp,  MemWrite, ALUSrc, RegWrite} <= 10'bX_1_0_X_0_XX_0_X_0; //J
        //doar cateva instructiuni
    endcase
  
endmodule

module MUX2_1 #(parameter n = 1) (a,b,sel,out);
  input [n-1:0]a,b;
  input sel; //mereu pe 1 bit
  output reg [n-1:0]out;
  always@(sel)
   	begin
      if(sel==0)
        out<=a;
      else
        out<=b;
    end
  
endmodule

module Sign_Extend(in,out);
  input [15:0] in;
  output [31:0] out;
  //adauga 16 biti de 0 la dreapta
  assign out = {16'b0,in};
endmodule

module Registers(ReadReg1, ReadReg2, WriteReg, WriteData, RegWrite, ReadData1, ReadData2);
  input [5:0]ReadReg1,ReadReg2,WriteReg;
  input RegWrite,WriteData;
  output [5:0] ReadData1,ReadData2;
  // primeste bucatile de instructiune
  // based on ce tip de instructine e, poate cere citiri/scrieri de registru/memorie
endmodule

module Add4(in,out);
  input [31:0]in;
  output [31:0]out;
  assign out=in+4;
endmodule

module ShiftLeft2_26(in,out);
  input [25:0]in;
  output [27:0]out;
  assign out={in,2'b0};
endmodule

module ShiftLeft2_32(in,out);
  input [31:0]in;
  output [31:0]out;
  assign out={in[29:0],2'b0};
endmodule

module Add32b(a,b,out);
  input[31:0]a,b;
  output[31:0]out;
  assign out=a+b;
  
endmodule

module ALUControl(fn,ALUOp,out);
  input [5:0] fn;
  input [1:0] ALUOp;
  output reg [2:0] out;
  always@(ALUOp,fn)
    casex({ALUOp,fn})
        8'b00_XXXXXX:out=010;//add
        8'bX1_XXXXXX:out=110;//sub
        8'b1X_100000:out=010;//add
        8'b1X_100010:out=110;//sub
        8'b1X_100100:out=000;//and
        8'b1X_100101:out=001;//or
        8'b1X_101010:out=111;//set less than        
    endcase
endmodule

module AND_gate(a,b,out);
  input a,b;
  output reg out;
  always@(a or b)
    begin
    	if(a==1 && b==1)
     	 out<=1;
  		else out<=0;
  	end
endmodule

module ALU(a,b,ALUControl,rez,zero);
  input [31:0]a,b;
  input [2:0]ALUControl;
  output reg [31:0] rez;
  output zero;
  always@(ALUControl)
    casex(ALUControl)
        3'b010: rez=a+b;//add
        3'b110: rez=a-b;//sub
        3'b000: rez=a&b;//and
        3'b001: rez=a|b;//or
        3'b111: rez=(a<b);//set less than
    endcase  
endmodule

module DataMemory(address,WriteData,MemWrite,ReadData);
  input [31:0] address, WriteData;
  input MemWrite;
  output [31:0] ReadData;
  // de facut scriere in memorie
endmodule

module concat(a,b,out); //pentru sarit undeva branch
  input [27:0] a;
  input [3:0] b;
  output [31:0] out;
  assign out = {b,a};
endmodule
